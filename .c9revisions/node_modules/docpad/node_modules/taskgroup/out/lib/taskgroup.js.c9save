{"ts":1377932916921,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"// Generated by CoffeeScript 1.6.3\nvar EventEmitter, Task, TaskGroup, ambi,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  __slice = [].slice,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\nambi = require('ambi');\n\nEventEmitter = require('events').EventEmitter;\n\nTask = (function(_super) {\n  __extends(Task, _super);\n\n  Task.prototype.type = 'task';\n\n  Task.prototype.result = null;\n\n  Task.prototype.running = false;\n\n  Task.prototype.completed = false;\n\n  Task.prototype.parent = null;\n\n  Task.prototype.taskDomain = null;\n\n  Task.prototype.name = null;\n\n  Task.prototype.method = null;\n\n  Task.prototype.args = null;\n\n  function Task() {\n    var args, method, name;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    Task.__super__.constructor.apply(this, arguments);\n    name = method = null;\n    if (args.length) {\n      if (args.length === 2) {\n        name = args[0], method = args[1];\n      } else if (args.length === 1) {\n        method = args[0];\n      }\n    }\n    this.setConfig({\n      name: name,\n      method: method\n    });\n    this;\n  }\n\n  Task.prototype.setConfig = function(opts) {\n    var key, value;\n    if (opts == null) {\n      opts = {};\n    }\n    for (key in opts) {\n      if (!__hasProp.call(opts, key)) continue;\n      value = opts[key];\n      this[key] = value;\n    }\n    return this;\n  };\n\n  Task.prototype.reset = function() {\n    this.completed = false;\n    this.running = false;\n    this.result = null;\n    return this;\n  };\n\n  Task.prototype.uncaughtExceptionCallback = function() {\n    var args, err;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    err = args[0];\n    if (!this.completed) {\n      this.complete(args);\n    }\n    this.emit('error', err);\n    return this;\n  };\n\n  Task.prototype.completionCallback = function() {\n    var args, err;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    if (!this.completed) {\n      this.complete(args);\n      this.emit.apply(this, ['complete'].concat(__slice.call(this.result)));\n    } else {\n      err = new Error(\"A task's completion callback has fired when the task was already in a completed state, this is unexpected\");\n      this.emit('error', err);\n    }\n    return this;\n  };\n\n  Task.prototype.destroy = function() {\n    this.removeAllListeners();\n    return this;\n  };\n\n  Task.prototype.complete = function(result) {\n    this.completed = true;\n    this.running = false;\n    this.result = result;\n    return this;\n  };\n\n  Task.prototype.fire = function() {\n    var args,\n      _this = this;\n    args = (this.args || []).concat([this.completionCallback.bind(this)]);\n    if (this.taskDomain == null) {\n      this.taskDomain = require('domain').create();\n      this.taskDomain.on('error', this.uncaughtExceptionCallback.bind(this));\n    }\n    this.taskDomain.run(function() {\n      return ambi.apply(null, [_this.method.bind(_this)].concat(__slice.call(args)));\n    });\n    return this;\n  };\n\n  Task.prototype.run = function() {\n    var err;\n    if (this.completed) {\n      err = new Error(\"A task was about to run but it has already completed, this is unexpected\");\n      this.emit('error', err);\n    } else {\n      this.reset();\n      this.running = true;\n      this.emit('run');\n      process.nextTick(this.fire.bind(this));\n    }\n    return this;\n  };\n\n  return Task;\n\n})(EventEmitter);\n\nTaskGroup = (function(_super) {\n  __extends(TaskGroup, _super);\n\n  TaskGroup.prototype.type = 'taskgroup';\n\n  TaskGroup.prototype.running = 0;\n\n  TaskGroup.prototype.remaining = null;\n\n  TaskGroup.prototype.err = null;\n\n  TaskGroup.prototype.results = null;\n\n  TaskGroup.prototype.parent = null;\n\n  TaskGroup.prototype.paused = true;\n\n  TaskGroup.prototype.bubbleEvents = null;\n\n  TaskGroup.prototype.name = null;\n\n  TaskGroup.prototype.method = null;\n\n  TaskGroup.prototype.concurrency = 1;\n\n  TaskGroup.prototype.pauseOnError = true;\n\n  function TaskGroup() {\n    var args, me, method, name;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    this.addGroup = __bind(this.addGroup, this);\n    this.addTask = __bind(this.addTask, this);\n    me = this;\n    TaskGroup.__super__.constructor.apply(this, arguments);\n    if (this.results == null) {\n      this.results = [];\n    }\n    if (this.remaining == null) {\n      this.remaining = [];\n    }\n    if (this.bubbleEvents == null) {\n      this.bubbleEvents = ['complete', 'run', 'error'];\n    }\n    name = method = null;\n    if (args.length) {\n      if (args.length === 2) {\n        name = args[0], method = args[1];\n      } else if (args.length === 1) {\n        method = args[0];\n      }\n    }\n    this.setConfig({\n      name: name,\n      method: method\n    });\n    process.nextTick(this.fire.bind(this));\n    this.on('item.complete', this.itemCompletionCallback.bind(this));\n    this.on('item.error', function(item, err) {\n      me.stop();\n      return me.emit('error', err);\n    });\n    this;\n  }\n\n  TaskGroup.prototype.setConfig = function(opts) {\n    var key, value;\n    if (opts == null) {\n      opts = {};\n    }\n    for (key in opts) {\n      if (!__hasProp.call(opts, key)) continue;\n      value = opts[key];\n      this[key] = value;\n    }\n    return this;\n  };\n\n  TaskGroup.prototype.fire = function() {\n    var args;\n    if (this.method) {\n      args = [this.addGroup, this.addTask];\n      this.addTask(this.method.bind(this)).setConfig({\n        args: args,\n        includeInResults: false\n      });\n      if (!this.parent) {\n        this.run();\n      }\n    }\n    return this;\n  };\n\n  TaskGroup.prototype.itemCompletionCallback = function() {\n    var args, item;\n    item = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n    if (item.includeInResults !== false) {\n      this.results.push(args);\n    }\n    if (args[0]) {\n      this.err = args[0];\n    }\n    if (this.running > 0) {\n      --this.running;\n    }\n    if (this.paused) {\n      return;\n    }\n    if (!this.complete()) {\n      this.nextItems();\n    }\n    return this;\n  };\n\n  TaskGroup.prototype.getTotals = function() {\n    var completed, remaining, running, total;\n    running = this.running;\n    remaining = this.remaining.length;\n    completed = this.results.length;\n    total = running + remaining + completed;\n    return {\n      running: running,\n      remaining: remaining,\n      completed: completed,\n      total: total\n    };\n  };\n\n  TaskGroup.prototype.addItem = function(item) {\n    var me;\n    me = this;\n    this.bubbleEvents.forEach(function(bubbleEvent) {\n      return item.on(bubbleEvent, function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return me.emit.apply(me, [\"item.\" + bubbleEvent, item].concat(__slice.call(args)));\n      });\n    });\n    this.emit('item.add', item);\n    this.remaining.push(item);\n    if (!this.paused) {\n      this.nextItems();\n    }\n    return item;\n  };\n\n  TaskGroup.prototype.createTask = function() {\n    var args, task;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    task = (function(func, args, ctor) {\n      ctor.prototype = func.prototype;\n      var child = new ctor, result = func.apply(child, args);\n      return Object(result) === result ? result : child;\n    })(Task, args, function(){});\n    return task;\n  };\n\n  TaskGroup.prototype.addTask = function() {\n    var args, me, task;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    me = this;\n    task = this.createTask.apply(this, args).setConfig({\n      parent: this\n    });\n    this.bubbleEvents.forEach(function(bubbleEvent) {\n      return task.on(bubbleEvent, function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return me.emit.apply(me, [\"task.\" + bubbleEvent, task].concat(__slice.call(args)));\n      });\n    });\n    this.emit('task.add', task);\n    return this.addItem(task);\n  };\n\n  TaskGroup.prototype.createGroup = function() {\n    var args, group;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    group = (function(func, args, ctor) {\n      ctor.prototype = func.prototype;\n      var child = new ctor, result = func.apply(child, args);\n      return Object(result) === result ? result : child;\n    })(TaskGroup, args, function(){});\n    return group;\n  };\n\n  TaskGroup.prototype.addGroup = function() {\n    var args, group, me;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    me = this;\n    group = this.createGroup.apply(this, args).setConfig({\n      concurrency: this.concurrency,\n      parent: this\n    });\n    this.bubbleEvents.forEach(function(bubbleEvent) {\n      return group.on(bubbleEvent, function() {\n        var args;\n        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n        return me.emit.apply(me, [\"group.\" + bubbleEvent, group].concat(__slice.call(args)));\n      });\n    });\n    this.emit('group.add', group);\n    return this.addItem(group);\n  };\n\n  TaskGroup.prototype.hasItems = function() {\n    return this.remaining.length !== 0;\n  };\n\n  TaskGroup.prototype.isReady = function() {\n    return !this.concurrency || this.running < this.concurrency;\n  };\n\n  TaskGroup.prototype.nextItems = function() {\n    var item, items, result;\n    items = [];\n    while (true) {\n      item = this.nextItem();\n      if (item) {\n        items.push(item);\n      } else {\n        break;\n      }\n    }\n    result = items.length ? items : false;\n    return result;\n  };\n\n  TaskGroup.prototype.nextItem = function() {\n    var nextItem;\n    if (this.hasItems()) {\n      if (this.isReady()) {\n        nextItem = this.remaining.shift();\n        ++this.running;\n        nextItem.run();\n        return nextItem;\n      }\n    }\n    return false;\n  };\n\n  TaskGroup.prototype.complete = function() {\n    var completed, empty, pause;\n    pause = this.pauseOnError && this.err;\n    empty = this.hasItems() === false && this.running === 0;\n    completed = pause || empty;\n    if (completed) {\n      if (pause) {\n        this.pause();\n      }\n      this.emit('complete', this.err, this.results);\n      this.err = null;\n      this.results = [];\n    }\n    return completed;\n  };\n\n  TaskGroup.prototype.clear = function() {\n    var item, _i, _len, _ref;\n    _ref = this.remaining.splice(0);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      item = _ref[_i];\n      item.destroy();\n    }\n    return this;\n  };\n\n  TaskGroup.prototype.destroy = function() {\n    this.stop();\n    this.removeAllListeners();\n    return this;\n  };\n\n  TaskGroup.prototype.stop = function() {\n    this.pause();\n    this.clear();\n    return this;\n  };\n\n  TaskGroup.prototype.exit = function(err) {\n    if (err) {\n      this.err = err;\n    }\n    this.stop();\n    this.running = 0;\n    this.complete();\n    return this;\n  };\n\n  TaskGroup.prototype.pause = function() {\n    this.paused = true;\n    return this;\n  };\n\n  TaskGroup.prototype.run = function() {\n    var args, me;\n    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    me = this;\n    this.paused = false;\n    this.emit('run');\n    process.nextTick(function() {\n      if (!me.complete()) {\n        return me.nextItems();\n      }\n    });\n    return this;\n  };\n\n  return TaskGroup;\n\n})(EventEmitter);\n\nmodule.exports = {\n  Task: Task,\n  TaskGroup: TaskGroup\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":11575}]],"length":11575}
